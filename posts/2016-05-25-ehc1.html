<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>A Silly Blog - Euphoria Haskell Course - Part 1</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">A Silly Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Euphoria Haskell Course - Part 1</h1>

            <div class="info">
    Posted on May 25, 2016
    
        by viviff
    
</div>

<h2 id="intro-to-haskell-and-functional-programming-and-lambda-calculus">Intro to Haskell and functional programming, and lambda calculus</h2>
<h3 id="functional-programming">Functional Programming</h3>
<p><a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a> is a purely functional programming language. It’s a <a href="https://en.wikipedia.org/wiki/General-purpose_programming_language">generic language</a>, meaning, it’s not domain specific.<br />
It’s <a href="https://en.wikipedia.org/wiki/Functional_programming">functional</a>, as functions are treated as first class values.<br />
It’s <a href="https://en.wikipedia.org/wiki/Purely_functional">purely functional</a>, as it excludes destructive modifications, like mutability.</p>
<h4 id="first-class-values.">First class values.</h4>
<p>So, what does a <a href="https://en.wikipedia.org/wiki/First-class_value">first class value</a> mean?<br />
First of all, what is a value? A value is anything that can be represented in the computer’s memory. A value ,for example, can be a number, a string, a date, but not necessarely just those. A programming language then defines a way to compute and work with these values, printing them to the screen, or adding them together, in case of numbers. So a first class value is simply something that we can pass as an argument, return from a function, or assign to a variable. In a functional language then, a function can be assigned to a variable, for a later computation, or passed to another function as a parameter, to implement a more generic code.</p>
<h4 id="functions">Functions</h4>
<p>The most general definition of a function is a mapping between two sets. A set is just a collection of elements, provided that no element is present multiple times.</p>
<p>Examples of a set would be</p>
<pre><code>A = {1,2,3}
B = {z,y,x}
C = {0}
D = {} (empty set)</code></pre>
<p>but not these ones, as elements are not unique in the set.</p>
<pre><code>E = {1,1,2}
F = {z,y,z}</code></pre>
<p>For example, a function f mapping from set A to B, would be:</p>
<blockquote>
<pre><code>f(1) = z
f(2) = y
f(3) = x</code></pre>
</blockquote>
<p>Or g:</p>
<blockquote>
<pre><code>g(1) = z
g(2) = z
g(3) = z</code></pre>
</blockquote>
<p>Or h:</p>
<blockquote>
<pre><code>h(1) = z</code></pre>
</blockquote>
<p>h is also called a <strong>partial</strong> function, as it doesn’t define the mapping for each element from A to B, while f and g, that do, are called <strong>total</strong> functions.</p>
<p>Another way of defining functions is by defining an expression to compute, like so:</p>
<blockquote>
<pre><code>f(x) = x + 1</code></pre>
</blockquote>
<p>f(x) is the <em>head</em> of the function, <em>x</em> is an argument of the function, while <em>x+1</em> is the body of the function.<br />
This allows to map for every input, a return value computed by the expression defined.</p>
<p>So, when that gets applied for each member of the set A, it becomes:</p>
<blockquote>
<pre><code>f(1) = 2
f(2) = 3
f(3) = 4</code></pre>
</blockquote>
<p>or also</p>
<blockquote>
<pre><code>f(1) = 1 + 1
f(2) = 2 + 1
f(3) = 3 + 1</code></pre>
</blockquote>
<p>And the two definitions are not distinguishable, as they have the same behaviour.<br />
And this brings us to the main point of this lesson.</p>
<h3 id="lambda-calculus.">Lambda Calculus.</h3>
<p>From <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia</a>:<br />
<em>Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.</em></p>
<p>So uh, that’s a lot. But basically it’s just <em>formal way of defining these computations</em>. We’ll see those abstractions and applications in the following paragraphs, don’t worry.</p>
<p>So, let’s start defining things, shall we?<br />
The lambda calculus has three lambda terms: expressions, variables and abstractions. Expressions are combinations of variables and abstractions. Variables are just terms for indicating possible inputs. And abstractions are functions, also called lambda.</p>
<pre><code>\x          -&gt;        x
Head     Separator   Body</code></pre>
<p>This is an abstraction. The head of the abstraction is simply the \ and a variable name, and the body is an expression (and yes, it can be another abstraction as well). This means that if we apply an argument to this function, that argument will be rewritten for each x in the body.</p>
<pre><code>(\x -&gt; x) 5
5
(\x -&gt; x * x) 3
3*3</code></pre>
<p>When applying an argument, we also remove the head of the lambda, leaving us with just the internal expression. Also, the argument in the head of the lambda, is called a bound variable, meaning that the value that variable holds, is bound by the argument passed in.</p>
<p>By the way, <strong>\x -&gt; x</strong> is called the identity function (id), and it’s the simplest abstraction, returning the argument given to it.</p>
<h4 id="alpha-equivalence">Alpha Equivalence</h4>
<p>The internal name of the variable doesn’t actually matter. The following lambdas are specifying the same behaviour.</p>
<pre><code>(\x -&gt; x * x)
(\y -&gt; y * y)
(\z -&gt; z * z)</code></pre>
<p>We can interchange the name of the bound variables, as long as we don’t use names already in use, inside the lambda expression, like free variables.</p>
<h4 id="free-variables">Free variables</h4>
<p>Those variables are simply variables which aren’t bound by an argument, but occur freely in an expression. In the following examples, z will be used as a free variable.</p>
<pre><code>(\x -&gt; x z)
(\x -&gt; z x)
(\x y -&gt; x y z) (\x -&gt; x)
z
(\x -&gt; x*z+1)</code></pre>
<p>If we take the first expression, and try to use an alpha equivalence, to change the name of x to z, we get this.</p>
<pre><code>(\z -&gt; z z)</code></pre>
<p>And this is a vastly different function, because now the parameter will replace both occurrences of <strong>z</strong>, while, before our alpha equivalence, we would have replaced just the first variable <strong>x</strong>. Compare:</p>
<pre><code>(\x -&gt; x z) 5
5 z
(\z -&gt; z z) 5
5 5</code></pre>
<p>And this means that, when there is a clash of names, there is a need to generate a new identifier, usually generated by adding a ' (prime) to the variable name.</p>
<pre><code>(\x -&gt; x z) 5
(\z' -&gt; z' z) 5
5 z</code></pre>
<p>And everything is fine again.</p>
<h4 id="beta-reduction">Beta Reduction</h4>
<p>And now we reduce. This is the way for the lambda calculus to reduce expressions. The previous examples did introduce the reduction implicitedly, when we remove an abstraction, by removing the head and separator, and replacing each occurrence of the head variable, with the parameter given.</p>
<p>Another thing: the separator is right associative, while the function application is left associative. This means <strong>f 3 2</strong>, actually means <strong>(f 3) 2</strong>, while<br />
<strong>\ x -&gt; \y -&gt; x * y</strong> means <strong>\x -&gt; (\y -&gt; x * y)</strong>.</p>
<p>Let’s look at some examples.</p>
<pre><code>(\x -&gt; x) 3
3

(\x -&gt; x x y) 2
2 2 y

(\x -&gt; x) (\y -&gt; y)
(\y -&gt; y)

(\x -&gt; x z x) (\y -&gt; y)
(\y -&gt; y) z (\y -&gt; y)
z (\y -&gt; y)</code></pre>
<p>And now for some more difficult examples, we shall use also alpha equivalence to avoid name clashes.</p>
<pre><code>(\x -&gt; x y) (\y -&gt; y)
(\y -&gt; y) y 
y

(\x -&gt; \y -&gt; x y) (\y -&gt; y)   -- First we reduce the x

(\y -&gt; (\y -&gt; y) y)           -- Uh-oh, bad case, ABORT!

(\x -&gt; \y -&gt; x y) (\y -&gt; y)   -- So, while reducing, we also need
       [1]    [1]             -- to change the name of y parameter
                              -- at [1], to avoid clashes. 

(\y' -&gt; (\y -&gt; y) y')         -- No more clashes! Let's continue 
                              -- with the body of the lambda as
                              -- there are no more arguments outside.

(\y' -&gt; y')                   -- And here we are, with our usual 
                              -- id function again.</code></pre>
<p>When we cannot reduce anymore, we call that expression <strong>normal form</strong> (actually beta normal form), and reducing also means computing values.</p>
<p>This also introduced…</p>
<h4 id="multiple-arguments-functions">Multiple Arguments Functions</h4>
<p>They don’t really exist. Well, maybe. They just are nested lambdas. These three definitions are exactly the same.</p>
<pre><code>(\x y -&gt; x * y)
(\x -&gt; \y -&gt; x * y)
(\x -&gt; (\y -&gt; x * y))</code></pre>
<p>Multiple parameters are basically functions returning other functions, with one less parameter to fill in.</p>
<h4 id="combinators">Combinators</h4>
<p>Just a quick note: these are lambda expressions that contain no free variables. They just combine the arguments they were given.</p>
<pre><code>(\x -&gt; x)
(\x y -&gt; y x)
(\x y z -&gt; z x y)
(\x y z -&gt; x y x)
...</code></pre>
<h4 id="divergence">Divergence</h4>
<p>These are lambda expressions that when beta reduced, they don’t get simpler, and computation regarding these terms cannot end.</p>
<pre><code>(\x -&gt; x x) (\y -&gt; y y)   -- substitution of x with (\y -&gt; y y)
((\y -&gt; y y) (\y -&gt; y y))
(\y -&gt; y y) (\y -&gt; y y)   -- With alpha equivalence, we already
                          -- know that we are back at the start.</code></pre>
<h4 id="more-examples.">More examples.</h4>
<pre><code>(\b -&gt; \a -&gt; b (\z -&gt; \x -&gt; z x x z) a z) x y
(\a -&gt; x (\z -&gt; \x -&gt; z x x z) a z) y
(x (\z -&gt; \x -&gt; z x x z) y z)
(x (\x -&gt; y x x y) z)
(x y z z y)</code></pre>
<hr />
<pre><code>(\x y -&gt; y x) ((\y z -&gt; y y z) y x) z -- we shall use the other syntax 
   [1]  [1]                           -- for these multi params.
(\y' -&gt; y' ((\y z -&gt; y y z) y x)) z   -- moved inside the x, renamed
                                      -- y [1] to y'
(z ((\y z -&gt; y y z) y x))
     [2]     [2]   [3]
(z ((\z -&gt; y y z) x))                 -- y as a bound variable in [2]
                                      -- was replaced with y as a 
                                      -- free variable in [3]
(z ((y y x)))
(z (y y x))
z (y y x)</code></pre>
<h4 id="exercises">Exercises:</h4>
<p>Reduce these expressions to the normal form.</p>
<pre><code> (\z -&gt; z) (\y -&gt; y y) (\x -&gt; x a)

 (\x -&gt; (\y -&gt;  x y y)) (\a -&gt; a) b

 (\x -&gt; x x) (\y -&gt; y x) z</code></pre>
<h3 id="additional-references">Additional References</h3>
<p><a href="https://wiki.haskell.org/Lambda_calculus">Lambda Calculus</a> on the Haskell Wiki.<br />
<a href="http://worrydream.com/AlligatorEggs/">Alligator Eggs</a> a fun diversion based on the Lambda Calculus.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
